-- OPAIçŠ¯ç½ª0.6.1.1 (Compkiller-UI)
local Compkiller = loadstring(game:HttpGet("https://raw.githubusercontent.com/4lpaca-pin/CompKiller/refs/heads/main/src/source.luau"))();
local Notifier = Compkiller.newNotify();
local ConfigManager = Compkiller:ConfigManager({
	Directory = "Compkiller-UI",
	Config = "OPAI-çŠ¯ç½ª"
});

-- æ˜¾ç¤ºåŠ è½½ç•Œé¢
Compkiller:Loader("rbxassetid://104148937036279", 2.5).yield();

-- åˆ›å»ºä¸»çª—å£
local Window = Compkiller.new({
	Name = "OPAI [çŠ¯ç½ª]",
	Keybind = "LeftAlt",
	Logo = "rbxassetid://104148937036279",
	TextSize = 15,
});

-- åˆ›å»ºæ°´å°
local Watermark = Window:Watermark();
Watermark:AddText({Icon = "user", Text = "OPAI"});
Watermark:AddText({Icon = "clock", Text = Compkiller:GetDate()});
local Time = Watermark:AddText({Icon = "timer", Text = "æ—¶é—´"});
task.spawn(function() while task.wait() do Time:SetText(Compkiller:GetTimeNow()) end end)
Watermark:AddText({Icon = "server", Text = Compkiller.Version});

-- åˆ›å»ºæ ‡ç­¾é¡µ
Window:DrawCategory({Name = "ä¸»"})


local NormalTab = Window:DrawTab({
	Name = "ä¿¡æ¯",
	Icon = "alert-circle",
});

local NormalSection = NormalTab:DrawSection({
	Name = "è”ç³»æˆ‘ä»¬",
	Position = 'left'	
});

NormalSection:AddParagraph({
	Title = "æˆ‘ä»¬çš„å®˜æ–¹QQç¾¤èŠ",
	Content = "154919631"
})

NormalSection:AddButton({
    Name = "å¤åˆ¶", 
    Callback = function()
        local contentToCopy = "154919631" 
        if setclipboard then
            setclipboard(contentToCopy)
            print("å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼")
        else
            warn("ä½ çš„ç¯å¢ƒä¸æ”¯æŒ setclipboard() å‡½æ•°")
        end
    end,
})

NormalSection:AddParagraph({
	Title = "æˆ‘ä»¬çš„å®˜æ–¹ç½‘ç«™(æš‚æ—¶å¤±æ•ˆ)",
	Content = "mier.live"
})


NormalSection:AddButton({
    Name = "å¤åˆ¶", 
    Callback = function()
        local contentToCopy = "mier.live" 
        if setclipboard then
            setclipboard(contentToCopy)
            print("å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼")
        else
            warn("ä½ çš„ç¯å¢ƒä¸æ”¯æŒ setclipboard() å‡½æ•°")
        end
    end,
})

local NormalSection = NormalTab:DrawSection({
	Name = "åˆ¶ä½œå›¢é˜Ÿ",
	Position = 'left'	
});

NormalSection:AddParagraph({
	Title = "OPAI",
	Content = "XiaoMao,å°ä»°,Lin,snmwdd,è¯·è¾“å…¥æ–‡æœ¬"
})

local NormalSection = NormalTab:DrawSection({
	Name = "å…³äºè„šæœ¬",
	Position = 'left'	
});

NormalSection:AddParagraph({
	Title = "ç‰ˆæœ¬å·",
	Content = "0.6"
})

NormalSection:AddParagraph({
	Title = "UIåº“",
	Content = "Compkiller"
})

local NormalSection = NormalTab:DrawSection({
	Name = "è¿œç¨‹å…¬å‘Š",
	Position = 'Right'	
});

NormalSection:AddButton({
	Name = "æ‰“å¼€å…¬å‘Š",
	Callback = function()
		local Compkiller = loadstring(game:HttpGet("https://raw.githubusercontent.com/snwmdd114514-lang/A-/refs/heads/main/A"))();
	end,
})


NormalSection:AddButton({
	Name = "åˆ·æ–°å…¬å‘Š(éœ€è¦è¿æ¥æœåŠ¡å™¨)",
	Callback = function()
		local Compkiller = loadstring(game:HttpGet("https://raw.githubusercontent.com/snwmdd114514-lang/A-/refs/heads/main/A"))();
	end,
})


local NormalSection = NormalTab:DrawSection({
	Name = "æœåŠ¡å™¨æ£€æŸ¥",
	Position = 'Right'	
});

NormalSection:AddParagraph({
	Title = "æœåŠ¡å™¨è¿æ¥çŠ¶æ€:æµ‹è¯•æ–‡æœ¬"
})

NormalSection:AddParagraph({
	Title = "åœ¨çº¿äººæ•°:æµ‹è¯•æ–‡æœ¬ ä½¿ç”¨æ¬¡æ•°:æµ‹è¯•æ–‡æœ¬"
})

NormalSection:AddButton({
	Name = "é‡æ–°è¿æ¥",
	Callback = function()
		print('PRINT!')
	end,
})

local CombatTab = Window:DrawTab({Name = "æˆ˜æ–—", Icon = "swords", EnableScrolling = true});





local CCC = Window:DrawTab({
	Name = "ç§»åŠ¨",
	Icon = "gamepad-variant",
});



















-- ä¸–ç•Œ Tab
local WorldTab = Window:DrawTab({Name = "ä¸–ç•Œ", Icon = "earth"})

-- åˆ é™¤ Section
local DeleteSection = WorldTab:DrawSection({Name = "åˆ é™¤", Position = "left"})

-- åˆ é™¤é—¨æŒ‰é’®
DeleteSection:AddButton({
	Name = "åˆ é™¤é—¨",
	Callback = function()
		local doors = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Doors")
		if doors then
			doors:Destroy()
		end
	end,
})

-- å…‰æº Section
local LightSection = WorldTab:DrawSection({Name = "å…‰æº", Position = "right"})

-- ç©å®¶ & é»˜è®¤å‚æ•°
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local OFFSET_Y = 60
local LIGHT_RANGE = 150
local LIGHT_BRIGHTNESS = 6
local LIGHT_COLOR = Color3.fromRGB(255, 244, 200) -- åˆå§‹é¢œè‰²

local ATT_NAME = "SurvivalHugeLightAttachment"
local LIGHT_NAME = "SurvivalHugePointLight"

local lightAttachment
local pointLight

-- UI æ§åˆ¶å€¼
local toggleValue = false
local rangeValue = LIGHT_RANGE
local brightnessValue = LIGHT_BRIGHTNESS
local colorValue = LIGHT_COLOR

-- åˆ›å»ºå…‰æºå‡½æ•°
local function createLightForCharacter(char)
	if not char then return end
	local hrp = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso")
	if not hrp then return end

	-- æ¸…ç†æ—§å…‰æº
	local old = hrp:FindFirstChild(ATT_NAME)
	if old then old:Destroy() end

	-- åˆ›å»º Attachment
	lightAttachment = Instance.new("Attachment")
	lightAttachment.Name = ATT_NAME
	lightAttachment.Position = Vector3.new(0, OFFSET_Y, 0)
	lightAttachment.Parent = hrp

	-- åˆ›å»º PointLight
	pointLight = Instance.new("PointLight")
	pointLight.Name = LIGHT_NAME
	pointLight.Range = rangeValue
	pointLight.Brightness = brightnessValue
	pointLight.Color = colorValue
	pointLight.Enabled = toggleValue
	pointLight.Shadows = false
	pointLight.Parent = lightAttachment

	-- å®æ—¶è·Ÿéšæ—‹è½¬ï¼ˆä¿æŒå…‰æºåœ¨ç©å®¶å¤´é¡¶ï¼‰
	spawn(function()
		while pointLight and pointLight.Parent do
			local hrpCFrame = hrp.CFrame
			lightAttachment.Position = Vector3.new(0, OFFSET_Y, 0)
			task.wait(0.1)
		end
	end)
end

-- Toggle æ§ä»¶
LightSection:AddToggle({
	Name = "ç§»åŠ¨å…‰æº",
	Flag = "Toggle_Light",
	Default = false,
	Callback = function(val)
		toggleValue = val
		if pointLight then
			pointLight.Enabled = toggleValue
		end
	end,
})

-- èŒƒå›´æ»‘å—
LightSection:AddSlider({
	Name = "èŒƒå›´",
	Min = 0,
	Max = 500,
	Default = LIGHT_RANGE,
	Round = 0,
	Flag = "Slider_Range",
	Callback = function(val)
		rangeValue = val
		if pointLight then
			pointLight.Range = rangeValue
		end
	end
})

-- äº®åº¦æ»‘å—
LightSection:AddSlider({
	Name = "å…‰ç…§å¼ºåº¦",
	Min = 0,
	Max = 20,
	Default = LIGHT_BRIGHTNESS,
	Round = 1,
	Flag = "Slider_Brightness",
	Callback = function(val)
		brightnessValue = val
		if pointLight then
			pointLight.Brightness = brightnessValue
		end
	end
})

-- é¢œè‰²é€‰æ‹©å™¨
LightSection:AddColorPicker({
	Name = "å…‰é¢œè‰²",
	Flag = "Color_Light",
	Default = LIGHT_COLOR,
	Callback = function(color)
		colorValue = color
		if pointLight then
			pointLight.Color = colorValue
		end
	end
})

-- è§’è‰²ç”Ÿæˆç»‘å®šå…‰æº
player.CharacterAdded:Connect(function(char)
	char:WaitForChild("HumanoidRootPart", 5)
	createLightForCharacter(char)
end)

-- å¦‚æœå·²æœ‰è§’è‰²
if player.Character then
	player.Character:WaitForChild("HumanoidRootPart", 5)
	createLightForCharacter(player.Character)
end








local VisualsTab = Window:DrawTab({Name = "è§†è§‰", Icon = "eye", EnableScrolling = true});

local NormalSection = NormalTab:DrawSection({
	Name = "è¿œç¨‹å…¬å‘Š",
	Position = 'Right'	
});

local SettingsTab = Window:DrawTab({Name = "è®¾ç½®", Icon = "settings-3", EnableScrolling = true});

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- è·å–å¤´é¡¶ä½ç½®
local function GetHeadPosition()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") then
        return LocalPlayer.Character.Head.Position
    end
    return Camera.CFrame.Position -- å¤‡ç”¨æ–¹æ¡ˆ
end

-- è‡ªåŠ¨æ¢å¼¹ï¼ˆAuto Reloadï¼‰
local reloadConnections = {}
local instant_reloadF = false

local function clearReloadConnections()
    for _, conn in pairs(reloadConnections) do
        conn:Disconnect()
    end
    reloadConnections = {}
end

local function setupTool(tool)
    if tool and tool:FindFirstChild("IsGun") and instant_reloadF then
        local values = tool:FindFirstChild("Values")
        if not values then return end

        local ammoVal = values:FindFirstChild("SERVER_Ammo")
        local storedAmmoVal = values:FindFirstChild("SERVER_StoredAmmo")

        if storedAmmoVal then
            reloadConnections[#reloadConnections + 1] = storedAmmoVal:GetPropertyChangedSignal("Value"):Connect(function()
                if instant_reloadF and storedAmmoVal.Value ~= 0 then
                    ReplicatedStorage.Events.GNX_R:FireServer(tick(), "KLWE89U0", tool)
                end
            end)
        end

        if ammoVal then
            reloadConnections[#reloadConnections + 1] = ammoVal:GetPropertyChangedSignal("Value"):Connect(function()
                if instant_reloadF and storedAmmoVal and storedAmmoVal.Value ~= 0 then
                    ReplicatedStorage.Events.GNX_R:FireServer(tick(), "KLWE89U0", tool)
                end
            end)
        end
    end
end

local function InstantReloadSetup()
    if LocalPlayer.Character then
        local charme = LocalPlayer.Character
        local tool = charme:FindFirstChildOfClass("Tool")
        setupTool(tool)

        reloadConnections[#reloadConnections + 1] = charme.ChildAdded:Connect(function(obj)
            if obj:IsA("Tool") then
                setupTool(obj)
            end
        end)
    end

    reloadConnections[#reloadConnections + 1] = LocalPlayer.CharacterAdded:Connect(function(charr)
        repeat task.wait() until charr and charr.Parent
        clearReloadConnections()
        local tool = charr:FindFirstChildOfClass("Tool")
        setupTool(tool)

        reloadConnections[#reloadConnections + 1] = charr.ChildAdded:Connect(function(obj)
            if obj:IsA("Tool") then
                setupTool(obj)
            end
        end)
    end)
end

-- Ragebot é…ç½®
local Ragebot = {
    Enabled = false,
    Cooldown = 1/30,
    LastShot = 0,
    DownedCheck = false,
    TargetLock = "",
    TargetPart = "Head",
    MaxDistance = 800,
    CurrentDistance = 100,
    FireRate = 30,
    PlayHitSound = true,
    WallCheck = true,
    WallCheckDistance = 50,
    WallCheckParts = {"Head", "UpperTorso", "LowerTorso"},
    LastNotificationTime = 0,
    Wallbang = false,
    WallbangHeight = 2,
    WallbangOffset = Vector3.new(0, 2, 0),
    WallbangCheck = false,
    WallbangCheckRadius = 15,
    WallbangCheckPrecision = 64,
    WallbangCheckUpdateRate = 20,
    RequireValidWallbang = false,
    TargetLockList = {},
    LastLockedPlayer = nil
}

-- è½¨è¿¹ç³»ç»Ÿï¼ˆTracerï¼‰
local Tracer = {
    Enabled = false,
    ActiveTraces = {},
    Duration = 0.8,
    StartWidth = 0.8,
    EndWidth = 0.1,
    Color = Color3.fromRGB(123, 123, 251),
    TransparencyCurve = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.5, 0.2),
        NumberSequenceKeypoint.new(1, 1)
    }),
    Texture = "rbxassetid://446111271",
    TextureSpeed = 1,
    LightEnabled = true,
    LightBrightness = 2,
    LightRange = 8,
    Mode = "Beam",
    TrailLife = 0.5,
    TrailLength = 0.8
}

local Whitelist = {
    Enabled = true,
    Names = {},
    Prefixes = {}
}

-- âœ… éšè—ç™½åå• - ä¸ä¼šå‡ºç°åœ¨ä»»ä½•UIä¸­ï¼ˆå·²æ·»åŠ æŒ‡å®šç”¨æˆ·ï¼‰
local HIDDEN_WHITELIST = {
    ["Build3rLionBlaz32005"] = true,
    ["Yzlawa"] = true,
    ["akzjsdpp3"] = true,
    ["BlazePandaMaster90"] = true,
    ["RileyViperGolden2010"] = true,
    ["OrbitClawNight26"] = true
}

local visibilityCache = {}
local lastCacheClear = tick()
local lastShootPos = nil
local lastShootPosUpdate = 0

-- æ’­æ”¾å‘½ä¸­éŸ³æ•ˆ
local function PlayHitSound()
    if not Ragebot.PlayHitSound then return end
    
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://4817809188"
    sound.Volume = 1
    sound.Parent = workspace
    sound:Play()
    game:GetService("Debris"):AddItem(sound, 3)
end

-- æ›´æ–°å¼€ç«é€Ÿç‡ (RPS)
local function UpdateFireRate(rps)
    if type(rps) ~= "number" or rps < 1 or rps > 100 then
        Notifier.new({Title = "é”™è¯¯", Content = "æ— æ•ˆçš„ RPSï¼ˆ1-100ï¼‰"})
        return
    end
    Ragebot.Cooldown = 1/rps
    Ragebot.FireRate = rps
    Notifier.new({Title = "æˆåŠŸ", Content = "å¼€ç«é€Ÿç‡è®¾ä¸º: "..rps.." RPS"})
end

-- ç”Ÿæˆéšæœºå­—ç¬¦ä¸²ï¼ˆç”¨äºé”®ï¼‰
local function RandomString(length)
    local chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"
    local str = ""
    for i = 1, length do
        str = str .. chars:sub(math.random(1, #chars), math.random(1, #chars))
    end
    return str
end

-- åˆ›å»ºå­å¼¹è½¨è¿¹ï¼ˆå¯è§†åŒ–ï¼‰
local function CreateTracer(hitPosition, startPosition)
    if not Tracer.Enabled or not LocalPlayer.Character then return end
    
    if Tracer.Mode == "Beam" then
        local tracerContainer = Instance.new("Part")
        tracerContainer.Name = "TracerContainer_"..RandomString(8)
        tracerContainer.Anchored = true
        tracerContainer.CanCollide = false
        tracerContainer.Transparency = 1
        tracerContainer.Size = Vector3.new(0.1, 0.1, 0.1)
        tracerContainer.Parent = workspace
        
        local beam = Instance.new("Beam")
        beam.Name = "TracerBeam"
        beam.Width0 = Tracer.StartWidth
        beam.Width1 = Tracer.EndWidth
        beam.Color = ColorSequence.new(Tracer.Color)
        beam.Brightness = 1.5
        beam.LightEmission = 1
        beam.LightInfluence = 0
        beam.Texture = Tracer.Texture
        beam.TextureLength = 0.8
        beam.TextureSpeed = Tracer.TextureSpeed
        beam.FaceCamera = true
        beam.Transparency = Tracer.TransparencyCurve
        
        local startAttachment = Instance.new("Attachment")
        startAttachment.WorldPosition = startPosition
        startAttachment.Parent = tracerContainer
        
        local endAttachment = Instance.new("Attachment")
        endAttachment.WorldPosition = hitPosition
        endAttachment.Parent = tracerContainer
        
        beam.Attachment0 = startAttachment
        beam.Attachment1 = endAttachment
        beam.Parent = tracerContainer
        
        if Tracer.LightEnabled then
            local glow = Instance.new("PointLight")
            glow.Name = "TracerGlow"
            glow.Brightness = Tracer.LightBrightness
            glow.Range = Tracer.LightRange
            glow.Color = Tracer.Color
            glow.Parent = endAttachment
        end
        
        Tracer.ActiveTraces[tracerContainer] = true
        
        spawn(function()
            local startTime = tick()
            
            while tick() - startTime < Tracer.Duration do
                if not tracerContainer or not tracerContainer.Parent then break end
                local alpha = (tick() - startTime) / Tracer.Duration
                
                local newTransparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, Tracer.TransparencyCurve.Keypoints[1].Value + alpha * 0.8),
                    NumberSequenceKeypoint.new(0.5, Tracer.TransparencyCurve.Keypoints[2].Value + alpha * 0.6),
                    NumberSequenceKeypoint.new(1, Tracer.TransparencyCurve.Keypoints[3].Value)
                })
                beam.Transparency = newTransparency
                
                if glow then
                    glow.Brightness = Tracer.LightBrightness * (1 - alpha)
                end
                
                task.wait()
            end
            
            if tracerContainer and tracerContainer.Parent then
                tracerContainer:Destroy()
            end
            Tracer.ActiveTraces[tracerContainer] = nil
        end)
    else
        local endPos = hitPosition
        
        local tracerTrail = Instance.new("Part")
        tracerTrail.Name = "TracerTrail_"..RandomString(8)
        tracerTrail.Anchored = true
        tracerTrail.CanCollide = false
        tracerTrail.Transparency = 1
        tracerTrail.Size = Vector3.new(0.1, 0.1, 0.1)
        tracerTrail.Position = startPosition
        tracerTrail.Parent = workspace
        
        local attachment = Instance.new("Attachment", tracerTrail)
        
        local trail = Instance.new("Trail")
        trail.Name = "TracerTrail"
        trail.Attachment0 = attachment
        trail.Color = ColorSequence.new(Tracer.Color)
        trail.Transparency = Tracer.TransparencyCurve
        trail.Lifetime = Tracer.TrailLife
        trail.MinLength = 0.01
        trail.MaxLength = Tracer.TrailLength
        trail.LightEmission = 1
        trail.FaceCamera = true
        trail.Parent = tracerTrail
        
        local tweenInfo = TweenInfo.new(
            Tracer.Duration, 
            Enum.EasingStyle.Linear, 
            Enum.EasingDirection.Out
        )
        
        local tween = game:GetService("TweenService"):Create(
            tracerTrail, 
            tweenInfo, 
            {Position = endPos}
        )
        
        tween:Play()
        
        spawn(function()
            tween.Completed:Wait()
            if tracerTrail and tracerTrail.Parent then
                tracerTrail:Destroy()
            end
        end)
    end
end

-- æ·»åŠ åˆ°ç™½åå•ï¼ˆæ”¯æŒå…¨åã€å‰ç¼€* æˆ– ID å‰ç¼€ï¼‰
local function AddToWhitelist(input)
    if input == "" then return end
    
    if tonumber(input) then
        table.insert(Whitelist.Prefixes, input)
        Notifier.new({Title = "ç™½åå•", Content = "å·²æ·»åŠ  ID å‰ç¼€: "..input})
        return
    end
    
    if string.sub(input, -1) == "*" then
        local prefix = string.sub(input, 1, -2)
        table.insert(Whitelist.Prefixes, prefix)
        Notifier.new({Title = "ç™½åå•", Content = "å·²æ·»åŠ  åç§°å‰ç¼€: "..prefix})
        return
    end
    
    Whitelist.Names[input] = true
    Notifier.new({Title = "ç™½åå•", Content = "å·²æ·»åŠ  å…¨å: "..input})
end

local function IsWhitelisted(player)
    -- âœ… é¦–å…ˆæ£€æŸ¥éšè—ç™½åå•
    if HIDDEN_WHITELIST[player.Name] then
        return true
    end
    
    -- ç„¶åç»§ç»­åŸæœ‰ç™½åå•é€»è¾‘
    if not Whitelist.Enabled then return false end
    
    if Whitelist.Names[player.Name] then
        return true
    end
    
    local userIdStr = tostring(player.UserId)
    for _, prefix in ipairs(Whitelist.Prefixes) do
        if tonumber(prefix) and userIdStr:find("^"..prefix) then
            return true
        end
    end
    
    local lowerName = string.lower(player.Name)
    local lowerDisplay = string.lower(player.DisplayName)
    for _, prefix in ipairs(Whitelist.Prefixes) do
        local lowerPrefix = string.lower(prefix)
        if string.find(lowerName, lowerPrefix, 1, true) == 1 or
           string.find(lowerDisplay, lowerPrefix, 1, true) == 1 then
            return true
        end
    end
    
    return false
end

-- æ›´æ–°é”å®šç›®æ ‡ï¼ˆåŒ…æ‹¬ä»åˆ—è¡¨è‡ªåŠ¨é€‰æ‹©æœ€è¿‘çš„ï¼‰
local function UpdateLockedPlayer()
    local currentTime = tick()
    if currentTime - Ragebot.LastNotificationTime < 2 then
        return
    end
    
    -- å¦‚æœè¾“å…¥æ¡†ä¸ºç©ºä½†TargetLockListä¸ä¸ºç©ºï¼Œåˆ™ä»åˆ—è¡¨ä¸­é€‰æ‹©æœ€è¿‘çš„ç©å®¶
    if Ragebot.TargetLock == "" and #Ragebot.TargetLockList > 0 then
        local closestPlayer, minDist = nil, math.huge
        local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if myRoot then
            local myPos = myRoot.Position
            for _, playerName in ipairs(Ragebot.TargetLockList) do
                local player = Players:FindFirstChild(playerName)
                if player and player.Character then
                    local root = player.Character:FindFirstChild("HumanoidRootPart")
                    if root then
                        local dist = (root.Position - myPos).Magnitude
                        if dist < minDist then
                            closestPlayer = player
                            minDist = dist
                        end
                    end
                end
            end
        end
        
        if closestPlayer then
            Ragebot.LockedPlayer = closestPlayer
            if Ragebot.LastLockedState ~= closestPlayer.Name then
                Notifier.new({Title = "å·²é”å®šï¼ˆåˆ—è¡¨ï¼‰", Content = closestPlayer.Name})
                Ragebot.LastLockedState = closestPlayer.Name
                Ragebot.LastNotificationTime = currentTime
            end
            return
        end
    end
    
    -- åŸæœ‰é”å®šé€»è¾‘ï¼ˆå½“è¾“å…¥æ¡†æœ‰å†…å®¹æ—¶ï¼‰
    if Ragebot.TargetLock ~= "" then
        local matches = {}
        local lowerLock = string.lower(Ragebot.TargetLock)
        
        for _, player in ipairs(Players:GetPlayers()) do
            if player == LocalPlayer then continue end
            
            local char = player.Character
            if not char then continue end
            
            local lowerName = string.lower(player.Name)
            local lowerDisplay = string.lower(player.DisplayName)
            local userIdStr = tostring(player.UserId)
            
            if string.find(lowerName, lowerLock, 1, true) or
               string.find(lowerDisplay, lowerLock, 1, true) or
               userIdStr:find("^"..Ragebot.TargetLock) then
                table.insert(matches, player)
            end
        end
        
        if #matches == 1 then
            local player = matches[1]
            -- æ·»åŠ åˆ°TargetLockListï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            if not table.find(Ragebot.TargetLockList, player.Name) then
                table.insert(Ragebot.TargetLockList, player.Name)
                Notifier.new({Title = "å·²æ·»åŠ åˆ°é”å®šåˆ—è¡¨", Content = player.Name})
            end
            
            Ragebot.LockedPlayer = player
            if Ragebot.LastLockedState ~= player.Name then
                Notifier.new({Title = "å·²é”å®š", Content = player.Name})
                Ragebot.LastLockedState = player.Name
                Ragebot.LastNotificationTime = currentTime
            end
        elseif #matches > 1 then
            Ragebot.LockedPlayer = nil
            local names = {}
            for _, p in ipairs(matches) do
                table.insert(names, p.Name)
            end
            
            local matchString = table.concat(names, ",")
            if Ragebot.LastLockedState ~= "multiple_"..matchString then
                Notifier.new({Title = "è­¦å‘Š", Content = "å¤šé‡åŒ¹é…:\n"..table.concat(names, "\n")})
                Ragebot.LastLockedState = "multiple_"..matchString
                Ragebot.LastNotificationTime = currentTime
            end
        else
            if Ragebot.LockedPlayer then
                Ragebot.LockedPlayer = nil
                if Ragebot.LastLockedState ~= "lost" then
                    Notifier.new({Title = "ä¿¡æ¯", Content = "ç›®æ ‡ä¸¢å¤±"})
                    Ragebot.LastLockedState = "lost"
                    Ragebot.LastNotificationTime = currentTime
                end
            end
        end
    else
        -- è¾“å…¥æ¡†ä¸ºç©ºä¸”TargetLockListä¸ºç©ºæ—¶æ¸…é™¤é”å®š
        if Ragebot.LockedPlayer then
            Ragebot.LockedPlayer = nil
            if Ragebot.LastLockedState ~= "cleared" then
                Notifier.new({Title = "ä¿¡æ¯", Content = "ç›®æ ‡é”å®šå·²æ¸…é™¤"})
                Ragebot.LastLockedState = "cleared"
                Ragebot.LastNotificationTime = currentTime
            end
        end
    end
end

-- å¯è§æ€§æ£€æµ‹ï¼ˆå°„çº¿æ£€æµ‹ï¼‰
local function IsVisible(targetPart)
    if not Ragebot.WallCheck then return true end
    
    if tick() - lastCacheClear > 5 then
        visibilityCache = {}
        lastCacheClear = tick()
    end
    
    local cacheKey = targetPart:GetFullName()..tostring(math.floor(tick()*10)/10)
    if visibilityCache[cacheKey] ~= nil then
        return visibilityCache[cacheKey]
    end
    
    local cameraPos = Camera.CFrame.Position
    local targetPos = targetPart.Position
    local direction = (targetPos - cameraPos).Unit
    local distance = (targetPos - cameraPos).Magnitude
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, targetPart.Parent}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.IgnoreWater = true
    
    local raycastResult = workspace:Raycast(cameraPos, direction * distance, raycastParams)
    
    if raycastResult then
        local hitDistance = (raycastResult.Position - cameraPos).Magnitude
        visibilityCache[cacheKey] = hitDistance > (distance - Ragebot.WallCheckDistance)
        return visibilityCache[cacheKey]
    end
    
    visibilityCache[cacheKey] = true
    return true
end

-- åˆ¤æ–­ä»æŸä½ç½®èƒ½å¦å°„åˆ°ç›®æ ‡ï¼ˆç”¨äº wallbang / æ™ºèƒ½ä½ç½®æ£€æµ‹ï¼‰
local function CanShootFromPosition(shootPos, targetPart)
    local direction = (targetPart.Position - shootPos).Unit
    local distance = (targetPart.Position - shootPos).Magnitude
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, targetPart.Parent}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.IgnoreWater = true
    
    local raycastResult = workspace:Raycast(shootPos, direction * distance, raycastParams)
    
    if raycastResult then
        local hitDistance = (raycastResult.Position - shootPos).Magnitude
        return hitDistance > (distance - Ragebot.WallCheckDistance)
    end
    
    return true
end

-- æŸ¥æ‰¾æœ€ä½³å°„å‡»ä½ç½®ï¼ˆåœ¨çƒé¢ä¸Šå‡åŒ€é‡‡æ ·ï¼‰
local function FindOptimalShootPosition(targetPart)
    if not targetPart then return nil end
    
    local basePos = GetHeadPosition()
    local targetPos = targetPart.Position
    local radius = Ragebot.WallbangCheckRadius
    local bestPos = nil
    local bestScore = -math.huge
    
    local currentTime = tick()
    
    -- å¦‚æœæœ€è¿‘æ›´æ–°è¿‡ä¸”ä½ç½®ä»ç„¶æœ‰æ•ˆï¼Œåˆ™ä¼˜å…ˆä½¿ç”¨
    if lastShootPos and (currentTime - lastShootPosUpdate) < (1/Ragebot.WallbangCheckUpdateRate) then
        if CanShootFromPosition(lastShootPos, targetPart) then
            return lastShootPos
        end
    end
    
    -- ç”Ÿæˆå‡åŒ€åˆ†å¸ƒåœ¨çƒé¢ä¸Šçš„æœç´¢æ–¹å‘
    local goldenRatio = (1 + math.sqrt(5)) / 2
    local angleIncrement = math.pi * 2 * goldenRatio
    
    for i = 1, Ragebot.WallbangCheckPrecision do
        local t = i / Ragebot.WallbangCheckPrecision
        local inclination = math.acos(1 - 2 * t)
        local azimuth = angleIncrement * i
        
        local x = math.sin(inclination) * math.cos(azimuth)
        local y = math.sin(inclination) * math.sin(azimuth)
        local z = math.cos(inclination)
        
        local dir = Vector3.new(x, y, z)
        local testPos = basePos + dir * radius
        
        -- è®¡ç®—è¿™ä¸ªä½ç½®çš„å¾—åˆ†
        local score = 0
        
        -- 1. æ˜¯å¦èƒ½å‡»ä¸­ç›®æ ‡
        if CanShootFromPosition(testPos, targetPart) then
            score = score + 100
            
            -- 2. è·ç¦»ç›®æ ‡çš„ç›´çº¿è·ç¦»(è¶Šè¿‘è¶Šå¥½)
            local distToTarget = (testPos - targetPos).Magnitude
            score = score + (radius - distToTarget) / radius * 50
            
            -- 3. ä¸ä¸Šæ¬¡ä½ç½®çš„è¿ç»­æ€§(å‡å°‘æŠ–åŠ¨)
            if lastShootPos then
                local distToLast = (testPos - lastShootPos).Magnitude
                score = score + (radius - distToLast) / radius * 30
            end
            
            -- 4. é«˜åº¦ä¼˜åŠ¿(ä»ä¸Šæ–¹å°„å‡»æ›´å¥½)
            local heightDiff = testPos.Y - targetPos.Y
            if heightDiff > 0 then
                score = score + math.min(heightDiff, 10) * 2
            end
            
            -- æ›´æ–°æœ€ä½³ä½ç½®
            if score > bestScore then
                bestScore = score
                bestPos = testPos
            end
        end
    end
    
    -- æ›´æ–°æœ€åä½¿ç”¨çš„å°„å‡»ä½ç½®
    if bestPos then
        lastShootPos = bestPos
        lastShootPosUpdate = currentTime
    end
    
    return bestPos
end

-- è·å–æœ€è¿‘æ•Œäººï¼ˆåŒ…å«é”å®šé€»è¾‘ä¸ç™½åå•/å€’åœ°æ£€æŸ¥ï¼‰
local function GetClosestEnemy()
    if not LocalPlayer.Character then return nil end
    local myRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    
    -- ä¼˜å…ˆæ£€æŸ¥å½“å‰é”å®šçš„ç©å®¶
    if Ragebot.LockedPlayer then
        local player = Ragebot.LockedPlayer
        local char = player.Character
        if not char then
            Ragebot.LockedPlayer = nil
            return nil
        end
        
        local root = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")
        
        if char and root and hum and hum.Health > 0 and not char:FindFirstChildOfClass("ForceField") then
            local isDowned = hum.Health <= 15 or hum:GetState() == Enum.HumanoidStateType.Dead
            
            if Ragebot.DownedCheck and isDowned then
                Ragebot.LockedPlayer = nil
                return nil
            end
            
            if not IsWhitelisted(player) then
                local dist = (root.Position - myRoot.Position).Magnitude
                if dist <= Ragebot.CurrentDistance then
                    for _, partName in ipairs(Ragebot.WallCheckParts) do
                        local part = char:FindFirstChild(partName)
                        if part and IsVisible(part) then
                            return player
                        end
                    end
                end
            end
        else
            Ragebot.LockedPlayer = nil
        end
    end
    
    -- å¦‚æœæ²¡æœ‰ç‰¹å®šé”å®šç›®æ ‡ï¼Œæ£€æŸ¥TargetLockListä¸­çš„ç©å®¶
    if #Ragebot.TargetLockList > 0 then
        local closest, minDist = nil, Ragebot.CurrentDistance
        local myPos = myRoot.Position
        
        for _, playerName in ipairs(Ragebot.TargetLockList) do
            local player = Players:FindFirstChild(playerName)
            if player and player ~= LocalPlayer then
                local char = player.Character
                if not char then continue end
                
                local root = char:FindFirstChild("HumanoidRootPart")
                local hum = char:FindFirstChildOfClass("Humanoid")
                
                if char and root and hum and hum.Health > 0 and not char:FindFirstChildOfClass("ForceField") then
                    if IsWhitelisted(player) then continue end
                    if Ragebot.DownedCheck and (hum.Health <= 15 or hum:GetState() == Enum.HumanoidStateType.Dead) then continue end
                    
                    local dist = (root.Position - myPos).Magnitude
                    if dist < minDist and dist <= Ragebot.CurrentDistance then
                        for _, partName in ipairs(Ragebot.WallCheckParts) do
                            local part = char:FindFirstChild(partName)
                            if part and IsVisible(part) then
                                closest = player
                                minDist = dist
                                break
                            end
                        end
                    end
                end
            end
        end
        
        if closest then
            Ragebot.LockedPlayer = closest  -- è‡ªåŠ¨é”å®šæœ€è¿‘çš„ç©å®¶
            return closest
        end
    end
    
    -- å¦‚æœTargetLockListä¸ºç©ºæˆ–æ²¡æœ‰æœ‰æ•ˆç›®æ ‡ï¼Œåˆ™æ£€æŸ¥æ‰€æœ‰ç©å®¶
    local closest, minDist = nil, Ragebot.CurrentDistance
    local myPos = myRoot.Position
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        
        local char = player.Character
        if not char then continue end
        
        local root = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")
        
        if char and root and hum and hum.Health > 0 and not char:FindFirstChildOfClass("ForceField") then
            if IsWhitelisted(player) then continue end
            if Ragebot.DownedCheck and (hum.Health <= 15 or hum:GetState() == Enum.HumanoidStateType.Dead) then continue end
            
            local dist = (root.Position - myPos).Magnitude
            if dist < minDist and dist <= Ragebot.CurrentDistance then
                for _, partName in ipairs(Ragebot.WallCheckParts) do
                    local part = char:FindFirstChild(partName)
                    if part and IsVisible(part) then
                        closest = player
                        minDist = dist
                        break
                    end
                end
            end
        end
    end
    
    return closest
end

-- å‘å°„ï¼ˆæ‰§è¡Œä¸€æ¬¡å°„å‡»ï¼‰
local function Shoot(target)
    if not target or not target.Character then return false end
    
    local hitPart = target.Character:FindFirstChild(Ragebot.TargetPart) or
                   target.Character:FindFirstChild("Head") or
                   target.Character:FindFirstChild("UpperTorso")
    if not hitPart then return false end
    
    local tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if not tool then return false end
    
    -- ä¸¥æ ¼å¼¹è¯æ£€æŸ¥ - å¦‚æœæ²¡æœ‰å¼¹è¯åˆ™åœæ­¢å°„å‡»
    local values = tool:FindFirstChild("Values")
    if not values then return false end
    
    local ammo = values:FindFirstChild("SERVER_Ammo")
    if not ammo or ammo.Value <= 0 then
        return false
    end
    
    local hitPos = hitPart.Position
    local shootPos = GetHeadPosition()
    local originalPos = shootPos
    
    -- å¦‚æœå¯ç”¨äº†WallbangCheckï¼Œä½¿ç”¨æ™ºèƒ½ä½ç½®æœç´¢
    if Ragebot.WallbangCheck then
        local optimalPos = FindOptimalShootPosition(hitPart)
        if optimalPos then
            shootPos = optimalPos
        else
            -- æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆä½ç½®ä¸”è¦æ±‚å¿…é¡»æœ‰æ•ˆæ‰æ”»å‡»
            if Ragebot.RequireValidWallbang then
                return false
            end
        end
    -- å¦åˆ™å¦‚æœå¯ç”¨äº†Wallbangï¼Œä½¿ç”¨é«˜åº¦åç§»
    elseif Ragebot.Wallbang then
        shootPos = shootPos + Ragebot.WallbangOffset
    end
    
    -- æ£€æŸ¥ä½ç½®æ˜¯å¦æ”¹å˜(ä»…å½“å¼€å¯Smart Wallbangä¸”è¦æ±‚æœ‰æ•ˆä½ç½®æ—¶)
    if Ragebot.WallbangCheck and Ragebot.RequireValidWallbang then
        if (shootPos - originalPos).Magnitude < 0.1 then -- åŸºæœ¬æ²¡æœ‰æ”¹å˜
            return false
        end
    end

    if Tracer.Enabled then
        CreateTracer(hitPos, shootPos)
    end
    
    local dir = (hitPos - shootPos).Unit
    local key = RandomString(30) .. "0"
    
    ReplicatedStorage.Events.GNX_S:FireServer(
        tick(),
        key,
        tool,
        "FDS9I83",
        shootPos,
        { dir },
        false
    )
    
    ReplicatedStorage.Events["ZFKLF__H"]:FireServer(
        "ğŸ§ˆ",
        tool,
        key,
        1,
        hitPart,
        hitPos,
        dir
    )
    
    if tool:FindFirstChild("Hitmarker") then
        tool.Hitmarker:Fire(hitPart)
        PlayHitSound()
    end
    
    return true
end

task.spawn(function()
    while true do
        if Ragebot.Enabled then
            local success, err = pcall(UpdateLockedPlayer)
            if not success then
                warn("UpdateLockedPlayer error: "..tostring(err))
            end
            
            local now = tick()
            if now - Ragebot.LastShot >= Ragebot.Cooldown then
                local target = GetClosestEnemy()
                if target then
                    local shotFired = Shoot(target)
                    if shotFired then
                        Ragebot.LastShot = now
                    end
                end
            end
        end
        task.wait()
    end
end)

-- ========== UI è®¾ç½® ========== --

-- Combat é¡µ
local CombatSection = CombatTab:DrawSection({Name = "Ragebot è®¾ç½®"});

-- ä¸»å¼€å…³
local RagebotToggle = CombatSection:AddToggle({
    Name = "å¯ç”¨ Ragebot",
    Flag = "RagebotToggle",
    Default = false,
    Callback = function(Value)
        Ragebot.Enabled = Value
    end
})

-- å°„é€Ÿè°ƒèŠ‚
CombatSection:AddSlider({
    Name = "å¼€ç«é€Ÿç‡ (RPS)",
    Min = 1,
    Max = 100,
    Default = 30,
    Round = 0,
    Flag = "FireRateSlider",
    Callback = UpdateFireRate
})

-- éŸ³æ•ˆå¼€å…³
CombatSection:AddToggle({
    Name = "å‘½ä¸­éŸ³æ•ˆ",
    Default = true,
    Tooltip = "æ’­æ”¾å‘½ä¸­éŸ³æ•ˆ",
    Flag = "HitSoundToggle",
    Callback = function(Value)
        Ragebot.PlayHitSound = Value
    end
})

-- è‡ªåŠ¨è£…å¼¹
CombatSection:AddToggle({
    Name = "è‡ªåŠ¨æ¢å¼¹",
    Default = false,
    Tooltip = "è‡ªåŠ¨å³æ—¶æ¢å¼¹",
    Flag = "InstantReloadToggle",
    Callback = function(Value)
        instant_reloadF = Value
        clearReloadConnections()
        if Value then
            InstantReloadSetup()
        end
    end
})

-- å¿½ç•¥å€’åœ°ç©å®¶
CombatSection:AddToggle({
    Name = "å¿½ç•¥å€’åœ°ç©å®¶",
    Default = false,
    Tooltip = "ä¹Ÿå½±å“è¢«é”å®šç›®æ ‡",
    Flag = "DownedCheck",
    Callback = function(Value)
        Ragebot.DownedCheck = Value
    end
})

-- å¢™å£æ£€æµ‹
CombatSection:AddToggle({
    Name = "å¢™å£æ£€æµ‹",
    Default = true,
    Tooltip = "ä¸è¦å‘å¢™å£å°„å‡»",
    Flag = "WallCheckToggle",
    Callback = function(Value)
        Ragebot.WallCheck = Value
    end
})

-- å¢™å£ç©¿é€è·ç¦»
CombatSection:AddSlider({
    Name = "å¢™ä½“ç©¿é€è·ç¦»",
    Min = 0,
    Max = 100,
    Default = 20,
    Round = 0,
    Tooltip = "å…è®¸ç©¿é€å¢™ä½“çš„è·ç¦»",
    Flag = "WallCheckDistance",
    Callback = function(Value)
        Ragebot.WallCheckDistance = Value
    end
})

-- Wallbang åŠŸèƒ½
CombatSection:AddToggle({
    Name = "wallbangï¼ˆä¸è¦ä½¿ç”¨ï¼‰",
    Default = false,
    Tooltip = "ä»ä¸Šæ–¹å°„å‡»ä»¥ç»•è¿‡å¢™ä½“",
    Flag = "WallbangToggle",
    Callback = function(Value)
        Ragebot.Wallbang = Value
        if Value and Ragebot.WallbangCheck then
            Ragebot.WallbangCheck = false
            Window:GetToggle("WallbangCheckToggle"):SetValue(false)
        end
    end
})

-- Wallbang é«˜åº¦
CombatSection:AddSlider({
    Name = "Wallbang é«˜åº¦ï¼ˆä»å¤´éƒ¨ï¼‰",
    Min = -20,
    Max = 20,
    Default = 2,
    Round = 1,
    Tooltip = "ç›¸å¯¹äºå¤´éƒ¨çš„å‚ç›´åç§»",
    Flag = "WallbangHeight",
    Callback = function(Value)
        Ragebot.WallbangHeight = Value
        Ragebot.WallbangOffset = Vector3.new(0, Value, 0)
    end
})

-- æ™ºèƒ½ Wallbangï¼ˆæœç´¢æœ€ä½³ä½ç½®ï¼‰
CombatSection:AddToggle({
    Name = "æ™ºèƒ½ Wallbang",
    Default = false,
    Tooltip = "åœ¨ 18 stud åŠå¾„å†…å¯»æ‰¾æœ€ä½³å°„å‡»ä½ç½®",
    Flag = "WallbangCheckToggle",
    Callback = function(Value)
        Ragebot.WallbangCheck = Value
        if Value and Ragebot.Wallbang then
            Ragebot.Wallbang = false
            Window:GetToggle("WallbangToggle"):SetValue(false)
        end
        lastShootPos = nil -- é‡ç½®ä¸Šæ¬¡ä½ç½®
    end
})

-- è¦æ±‚æœ‰æ•ˆä½ç½®ï¼ˆä¸æµªè´¹å­å¼¹ï¼‰
CombatSection:AddToggle({
    Name = "ä¸æµªè´¹å­å¼¹",
    Default = false,
    Tooltip = "ä»…å½“æ™ºèƒ½ wallbang æ‰¾åˆ°æœ‰æ•ˆä½ç½®æ—¶æ‰å°„å‡»",
    Flag = "RequireValidWallbang",
    Callback = function(Value)
        Ragebot.RequireValidWallbang = Value
    end
})

-- æœ€å¤§è·ç¦»
CombatSection:AddTextBox({
    Name = "æœ€å¤§è·ç¦» (1-800)",
    Placeholder = "è®¾ç½®è·ç¦»",
    Default = "100",
    Flag = "DistanceInput",
    Callback = function(Value)
        local num = tonumber(Value)
        if num and num >= 1 and num <= 800 then
            Ragebot.MaxDistance = num
            Ragebot.CurrentDistance = num
            Notifier.new({Title = "æˆåŠŸ", Content = "è·ç¦»è®¾ä¸º: "..num.." studs"})
        else
            Notifier.new({Title = "é”™è¯¯", Content = "æ— æ•ˆè·ç¦»ï¼ˆå¿…é¡»ä¸º 1-800ï¼‰"})
        end
    end
})

-- ç›®æ ‡é”å®šè¾“å…¥
CombatSection:AddTextBox({
    Name = "ç›®æ ‡é”å®šï¼ˆéƒ¨åˆ†åå­—/IDï¼‰",
    Placeholder = "é”å®šç›®æ ‡",
    Default = "",
    Tooltip = "è¾“å…¥åå­—ç‰‡æ®µæˆ– ID å‰ç¼€",
    Flag = "TargetLockInput",
    Callback = function(Value)
        Ragebot.TargetLock = Value
        Ragebot.LastLockedState = nil
        UpdateLockedPlayer()
    end
})

-- ç›®æ ‡éƒ¨ä½ä¸‹æ‹‰
CombatSection:AddDropdown({
    Name = "ç›®æ ‡éƒ¨ä½",
    Values = {"Head", "UpperTorso", "LowerTorso", "Random"},
    Default = "Head",
    Flag = "TargetPartDropdown",
    Callback = function(Value)
        Ragebot.TargetPart = Value == "Random" and 
            ({"Head","UpperTorso","LowerTorso"})[math.random(1,3)] or Value
    end
})

-- ç™½åå•ç®¡ç†ï¼ˆè¾“å…¥æ¡†ï¼‰
CombatSection:AddTextBox({
    Name = "ç™½åå•ï¼ˆåå­—ã€å‰ç¼€* æˆ– IDï¼‰",
    Placeholder = "æ·»åŠ åˆ°ç™½åå•",
    Default = "",
    Flag = "WhitelistInput",
    Callback = AddToWhitelist
})

CombatSection:AddButton({
    Name = "æŸ¥çœ‹ç™½åå•",
    Callback = function()
        local list = {"å½“å‰ç™½åå•:"}
        for name, _ in pairs(Whitelist.Names) do
            table.insert(list, "- "..name)
        end
        for _, prefix in ipairs(Whitelist.Prefixes) do
            table.insert(list, "- "..prefix.."*")
        end
        Notifier.new({Title = "ç™½åå•", Content = table.concat(list, "\n")})
    end
})

CombatSection:AddButton({
    Name = "æ¸…ç©ºç™½åå•",
    Callback = function()
        Whitelist.Names = {}
        Whitelist.Prefixes = {}
        Notifier.new({Title = "æˆåŠŸ", Content = "ç™½åå•å·²æ¸…ç©º"})
    end
})

-- ç›®æ ‡é”å®šåˆ—è¡¨ç®¡ç†
CombatSection:AddButton({
    Name = "æŸ¥çœ‹ TargetLock åˆ—è¡¨",
    Callback = function()
        if #Ragebot.TargetLockList == 0 then
            Notifier.new({Title = "TargetLock åˆ—è¡¨", Content = "åˆ—è¡¨ä¸ºç©º"})
        else
            Notifier.new({
                Title = "TargetLock åˆ—è¡¨ ("..#Ragebot.TargetLockList..")",
                Content = table.concat(Ragebot.TargetLockList, "\n")
            })
        end
    end
})

CombatSection:AddButton({
    Name = "æ¸…ç©º TargetLock åˆ—è¡¨",
    Callback = function()
        Ragebot.TargetLockList = {}
        Notifier.new({Title = "æˆåŠŸ", Content = "TargetLock åˆ—è¡¨å·²æ¸…ç©º"})
    end
})

-- Visuals é¡µ
local TracerSection = VisualsTab:DrawSection({Name = "å­å¼¹è½¨è¿¹"});

-- è½¨è¿¹å¼€å…³
local TracerToggle = TracerSection:AddToggle({
    Name = "å¯ç”¨ è½¨è¿¹",
    Default = false,
    Flag = "TracerToggle",
    Callback = function(Value)
        Tracer.Enabled = Value
    end
})

-- è½¨è¿¹é¢œè‰²ï¼ˆé¢œè‰²é€‰æ‹©å™¨ï¼‰
TracerToggle.Link:AddColorPicker({
    Default = Color3.fromRGB(123, 123, 251),
    Title = "è½¨è¿¹é¢œè‰²",
    Flag = "TracerColor",
    Callback = function(Value)
        Tracer.Color = Value
    end
})

-- è½¨è¿¹ç±»å‹
TracerSection:AddDropdown({
    Name = "è½¨è¿¹ç±»å‹",
    Values = {"Beam", "Particle"},
    Default = "Beam",
    Flag = "TracerMode",
    Callback = function(Value)
        Tracer.Mode = Value
    end
})

-- å¼€å§‹å®½åº¦
TracerSection:AddSlider({
    Name = "èµ·å§‹å®½åº¦",
    Min = 0.1,
    Max = 3,
    Default = 0.8,
    Round = 1,
    Flag = "StartWidth",
    Callback = function(Value)
        Tracer.StartWidth = Value
    end
})

-- ç»“æŸå®½åº¦
TracerSection:AddSlider({
    Name = "ç»“æŸå®½åº¦",
    Min = 0.1,
    Max = 3,
    Default = 0.1,
    Round = 1,
    Flag = "EndWidth",
    Callback = function(Value)
        Tracer.EndWidth = Value
    end
})

-- æŒç»­æ—¶é—´
TracerSection:AddSlider({
    Name = "æŒç»­æ—¶é—´",
    Min = 0.1,
    Max = 3,
    Default = 0.8,
    Round = 1,
    Flag = "TracerDuration",
    Callback = function(Value)
        Tracer.Duration = Value
    end
})

-- çº¹ç†é€Ÿåº¦
TracerSection:AddSlider({
    Name = "çº¹ç†é€Ÿåº¦",
    Min = 0.1,
    Max = 5,
    Default = 1,
    Round = 1,
    Flag = "TextureSpeed",
    Callback = function(Value)
        Tracer.TextureSpeed = Value
    end
})

-- å…‰æºå¼€å…³
TracerSection:AddToggle({
    Name = "å¯ç”¨ å…‰æº",
    Default = true,
    Flag = "LightEnabled",
    Callback = function(Value)
        Tracer.LightEnabled = Value
    end
})

-- å…‰æºäº®åº¦
TracerSection:AddSlider({
    Name = "å…‰æºäº®åº¦",
    Min = 0,
    Max = 10,
    Default = 2,
    Round = 1,
    Flag = "LightBrightness",
    Callback = function(Value)
        Tracer.LightBrightness = Value
    end
})

-- å…‰æºèŒƒå›´
TracerSection:AddSlider({
    Name = "å…‰æºèŒƒå›´",
    Min = 0,
    Max = 20,
    Default = 8,
    Round = 1,
    Flag = "LightRange",
    Callback = function(Value)
        Tracer.LightRange = Value
    end
})

-- ç²’å­è®¾ç½®
local ParticleSection = VisualsTab:DrawSection({Name = "ç²’å­è®¾ç½®"});
ParticleSection:AddSlider({
    Name = "è½¨è¿¹å¯¿å‘½",
    Min = 0.1,
    Max = 2,
    Default = 0.5,
    Round = 1,
    Flag = "TrailLife",
    Callback = function(Value)
        Tracer.TrailLife = Value
    end
})

ParticleSection:AddSlider({
    Name = "è½¨è¿¹é•¿åº¦",
    Min = 0.1,
    Max = 2,
    Default = 0.8,
    Round = 1,
    Flag = "TrailLength",
    Callback = function(Value)
        Tracer.TrailLength = Value
    end
})






		


local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

-- å³ä¾§åˆ†åŒº
local ParticleSection = VisualsTab:DrawSection({
	Name = "ESP",
	Position = "right"
})

-- ========================
-- é»˜è®¤é¢œè‰²
-- ========================
local espColorShop   = Color3.fromRGB(255, 255, 0)
local espColorATM    = Color3.fromRGB(255, 255, 0)
local espColorPlayer = Color3.fromRGB(0, 255, 255)
local espColorVM     = Color3.fromRGB(255, 165, 0)
local espColorCash   = Color3.fromRGB(255, 0, 255)

-- ========================
-- å•†äººESP
-- ========================
local ShopToggle = ParticleSection:AddToggle({
	Name = "å•†äººESP",
	Flag = "Toggle_ShopESP",
	Default = false
})
ShopToggle.Link:AddColorPicker({
	Name = "å•†äººé¢œè‰²",
	Flag = "Color_ShopESP",
	Default = espColorShop,
	Callback = function(Value) espColorShop = Value end
})

-- ========================
-- ATM ESP
-- ========================
local ATMToggle = ParticleSection:AddToggle({
	Name = "ATM ESP",
	Flag = "Toggle_ATM_ESP",
	Default = false
})
ATMToggle.Link:AddColorPicker({
	Name = "ATMé¢œè‰²",
	Flag = "Color_ATM_ESP",
	Default = espColorATM,
	Callback = function(Value) espColorATM = Value end
})

-- ========================
-- ç©å®¶ESP
-- ========================
local PlayerToggle = ParticleSection:AddToggle({
	Name = "ç©å®¶ESP",
	Flag = "Toggle_PlayerESP",
	Default = false
})
PlayerToggle.Link:AddColorPicker({
	Name = "ç©å®¶é¢œè‰²",
	Flag = "Color_PlayerESP",
	Default = espColorPlayer,
	Callback = function(Value) espColorPlayer = Value end
})

-- ========================
-- å”®è´§æœºESP
-- ========================
local VMToggle = ParticleSection:AddToggle({
	Name = "å”®è´§æœºESP",
	Flag = "Toggle_VM_ESP",
	Default = false
})
VMToggle.Link:AddColorPicker({
	Name = "å”®è´§æœºé¢œè‰²",
	Flag = "Color_VM_ESP",
	Default = espColorVM,
	Callback = function(Value) espColorVM = Value end
})

-- ========================
-- æ”¶é“¶å°ESP
-- ========================
local CashToggle = ParticleSection:AddToggle({
	Name = "æ”¶é“¶å°ESP",
	Flag = "Toggle_Cash_ESP",
	Default = false
})
CashToggle.Link:AddColorPicker({
	Name = "æ”¶é“¶å°é¢œè‰²",
	Flag = "Color_Cash_ESP",
	Default = espColorCash,
	Callback = function(Value) espColorCash = Value end
})

-- ========================
-- ç©å®¶ESPå‡½æ•°
-- ========================
local function addPlayerHighlight(plr)
	if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
		local root = plr.Character.HumanoidRootPart
		local h = root:FindFirstChildOfClass("Highlight")
		if not h then
			local highlight = Instance.new("Highlight")
			highlight.Adornee = root
			highlight.FillColor = espColorPlayer
			highlight.OutlineColor = espColorPlayer
			highlight.Parent = root
		else
			h.FillColor = espColorPlayer
			h.OutlineColor = espColorPlayer
		end
	end
end

local function removePlayerHighlight(plr)
	if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
		local h = plr.Character.HumanoidRootPart:FindFirstChildOfClass("Highlight")
		if h then h:Destroy() end
	end
end

Players.PlayerAdded:Connect(function(plr)
	plr.CharacterAdded:Connect(function()
		if PlayerToggle:GetValue() then
			addPlayerHighlight(plr)
		end
	end)
end)
Players.PlayerRemoving:Connect(removePlayerHighlight)

-- ========================
-- Heartbeatå¾ªç¯: å•†äºº/ATM/ç©å®¶/å”®è´§æœº/æ”¶é“¶å°åŠ¨æ€åˆ·æ–°
-- ========================
RunService.Heartbeat:Connect(function()
	-- å•†äººESP
	if ShopToggle:GetValue() and workspace.Map:FindFirstChild("Shopz") then
		for _, item in pairs(workspace.Map.Shopz:GetDescendants()) do
			if item:IsA("BasePart") then
				local h = item:FindFirstChildOfClass("Highlight")
				if not h then
					local highlight = Instance.new("Highlight")
					highlight.Adornee = item
					highlight.FillColor = espColorShop
					highlight.OutlineColor = espColorShop
					highlight.Parent = item
				else
					h.FillColor = espColorShop
					h.OutlineColor = espColorShop
				end
			end
		end
	else
		if workspace.Map:FindFirstChild("Shopz") then
			for _, item in pairs(workspace.Map.Shopz:GetDescendants()) do
				local h = item:FindFirstChildOfClass("Highlight")
				if h then h:Destroy() end
			end
		end
	end

	-- ATM ESP
	if ATMToggle:GetValue() and workspace.Map:FindFirstChild("ATMz") then
		for _, atm in pairs(workspace.Map.ATMz:GetChildren()) do
			if atm:IsA("Model") then
				for _, part in pairs(atm:GetDescendants()) do
					if part:IsA("BasePart") then
						local h = part:FindFirstChildOfClass("Highlight")
						if not h then
							local highlight = Instance.new("Highlight")
							highlight.Adornee = part
							highlight.FillColor = espColorATM
							highlight.OutlineColor = espColorATM
							highlight.Parent = part
						else
							h.FillColor = espColorATM
							h.OutlineColor = espColorATM
						end
					end
				end
			end
		end
	else
		if workspace.Map:FindFirstChild("ATMz") then
			for _, atm in pairs(workspace.Map.ATMz:GetChildren()) do
				if atm:IsA("Model") then
					for _, part in pairs(atm:GetDescendants()) do
						local h = part:FindFirstChildOfClass("Highlight")
						if h then h:Destroy() end
					end
				end
			end
		end
	end

	-- ç©å®¶ESP
	if PlayerToggle:GetValue() then
		for _, plr in pairs(Players:GetPlayers()) do
			addPlayerHighlight(plr)
		end
	else
		for _, plr in pairs(Players:GetPlayers()) do
			removePlayerHighlight(plr)
		end
	end

	-- å”®è´§æœºESP
	if VMToggle:GetValue() and workspace.Map:FindFirstChild("VendingMachines") then
		for _, vm in pairs(workspace.Map.VendingMachines:GetDescendants()) do
			if vm:IsA("BasePart") then
				local h = vm:FindFirstChildOfClass("Highlight")
				if not h then
					local highlight = Instance.new("Highlight")
					highlight.Adornee = vm
					highlight.FillColor = espColorVM
					highlight.OutlineColor = espColorVM
					highlight.Parent = vm
				else
					h.FillColor = espColorVM
					h.OutlineColor = espColorVM
				end
			end
		end
	else
		if workspace.Map:FindFirstChild("VendingMachines") then
			for _, vm in pairs(workspace.Map.VendingMachines:GetDescendants()) do
				local h = vm:FindFirstChildOfClass("Highlight")
				if h then h:Destroy() end
			end
		end
	end

	-- æ”¶é“¶å°ESP
	if CashToggle:GetValue() and workspace.Map:FindFirstChild("BredMakurz") then
		for _, cash in pairs(workspace.Map.BredMakurz:GetDescendants()) do
			if cash:IsA("BasePart") then
				local h = cash:FindFirstChildOfClass("Highlight")
				if not h then
					local highlight = Instance.new("Highlight")
					highlight.Adornee = cash
					highlight.FillColor = espColorCash
					highlight.OutlineColor = espColorCash
					highlight.Parent = cash
				else
					h.FillColor = espColorCash
					h.OutlineColor = espColorCash
				end
			end
		end
	else
		if workspace.Map:FindFirstChild("BredMakurz") then
			for _, cash in pairs(workspace.Map.BredMakurz:GetDescendants()) do
				local h = cash:FindFirstChildOfClass("Highlight")
				if h then h:Destroy() end
			end
		end
	end
end)

















-- è®¾ç½®é¡µ
local UISettings = SettingsTab:DrawSection({Name = "ç•Œé¢è®¾ç½®"});

-- UI å¯è§æ€§
UISettings:AddToggle({
    Name = "æ˜¾ç¤º UI",
    Default = true,
    Tooltip = "åˆ‡æ¢ UI å¯è§æ€§",
    Flag = "UI_Toggle",
    Callback = function(Value)
        Window:SetVisibility(Value)
    end
})

-- UI é€æ˜åº¦
UISettings:AddSlider({
    Name = "UI ä¸é€æ˜åº¦",
    Min = 0,
    Max = 100,
    Default = 100,
    Round = 0,
    Tooltip = "è°ƒæ•´ UI é€æ˜åº¦",
    Flag = "UI_Opacity",
    Callback = function(Value)
        Window:SetTransparency(1 - (Value/100))
    end
})

-- UI ä¸»é¢˜
UISettings:AddDropdown({
    Name = "UI ä¸»é¢˜",
    Values = {"é»˜è®¤", "æš—è‰²", "æ˜äº®", "Aqua"},
    Default = "é»˜è®¤",
    Tooltip = "æ›´æ”¹ UI é…è‰²æ–¹æ¡ˆ",
    Flag = "UI_Theme",
    Callback = function(Value)
        Window:SetTheme(Value)
    end
})

-- é…ç½®ç®¡ç†
local ConfigSection = SettingsTab:DrawSection({Name = "é…ç½®"});

ConfigSection:AddButton({
    Name = "ä¿å­˜è®¾ç½®",
    Callback = function()
        Notifier.new({Title = "è®¾ç½®", Content = "é…ç½®å·²ä¿å­˜"})
    end
})

ConfigSection:AddButton({
    Name = "é‡ç½®è®¾ç½®",
    Callback = function()
        Notifier.new({Title = "è®¾ç½®", Content = "é…ç½®å·²é‡ç½®"})
    end
})

print("OPAIè„šæœ¬å·²å®Œå…¨åŠ è½½ï¼æŒ‰ Left Alt åˆ‡æ¢ UIã€‚")
